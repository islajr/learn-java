plugins {
    id 'application'    // this facilitates the creation of an executable jvm application
                        // declaring this implicitly declares the 'java' plugin that adds compilation and testing to the project.

}

// declaring the 'application' plugin allows us to do this - inserting the 'main' class.
application {
    mainClass = 'org.example.Main'
}

group = 'org.example'
version = '1.0-SNAPSHOT'

// repositories

repositories {
    mavenCentral()
}

// dependencies

dependencies {
    testImplementation platform('org.junit:junit-bom:5.9.1')    // used for unit-testing.
    testImplementation 'org.junit.jupiter:junit-jupiter'    // also used for unit-testing.
}

// unit testing

test {
    useJUnitPlatform()
}

// tasks

tasks.register("hello") {
    doLast {
        println("hello!")
    }
}

tasks.register("greet") {
    doLast {
        println("how are you?")

    }

    dependsOn(hello)

    /*
    this is a demonstration of dependencies in gradle tasks.
    in this case, 'hello' runs before 'greet'.

    it is worth noting that task execution order is determined by gradle depending on the way the dependencies are defined (explicitly or implicitly).

    however, if there are no dependencies between tasks, gradle allows users to define their execution order.
    */
}

// to add specific java toolchain to ease working on different environments...
/*
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(11)
    }
}
*/

